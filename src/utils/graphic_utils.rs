use crate::utils::math_util::lerp;
use std::cmp::max;

use super::super::objs::typedef::Vec3;
pub trait Noise3D {
    /// generic 3d noise function
    ///
    /// * `x`: x coord
    /// * `y`: y coord
    /// * `z`: z coord
    fn noise(x: f32, y: f32, z: f32) -> f32;
}

pub struct Perlin;

impl Perlin {
    const PERM: [u8; 512] = [
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
        69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94,
        252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
        168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
        211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1,
        216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
        164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118,
        126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
        213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39,
        253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,
        192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
        138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
        69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94,
        252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
        168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
        211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1,
        216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
        164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118,
        126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
        213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39,
        253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,
        192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
        138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
    ];
    fn fade(t: f32) -> f32 {
        ((6.0 * t - 15.0) * t + 10.0) * t * t * t
    }
    /// get a constant vector based on the index given
    /// vertex is picked by first 3 bits of the index
    /// where (0, 0, 0) is in the center of the cube
    /// so order is:
    ///    2─────────1
    ///   /│        /│
    ///  / │       / │
    /// 3──┼──────0  │
    /// │  │      │  │
    /// │  │      │  │
    /// │  6──────┼──5
    /// │ /       │ /
    /// │/        │/
    /// 7─────────4
    ///
    /// * `n`:index
    fn const_vec_cubical(n: u8) -> Vec3 {
        match n & 7 {
            0 => Vec3::new(1.0, 1.0, 1.0),
            1 => Vec3::new(1.0, 1.0, -1.0),
            2 => Vec3::new(-1.0, 1.0, -1.0),
            3 => Vec3::new(-1.0, 1.0, 1.0),
            4 => Vec3::new(1.0, -1.0, 1.0),
            5 => Vec3::new(1.0, -1.0, -1.0),
            6 => Vec3::new(-1.0, -1.0, -1.0),
            7 => Vec3::new(-1.0, -1.0, 1.0),
            _ => panic!("cubical const vec got value greater than 7"),
        }
    }

    /// get permutation values for the 8 verticies of the cube
    /// but this time we are using far lower left as (0, 0, 0)
    /// so the order is:
    ///    3─────────0
    ///   /│        /│
    ///  / │       / │
    /// 2──┼──────1  │
    /// │  │      │  │
    /// │  │      │  │
    /// │  7──────┼──4
    /// │ /       │ /
    /// │/        │/
    /// 6─────────5
    ///
    /// * `x`: x coord
    /// * `y`: y coord
    /// * `z`: z coord
    fn gradient_dot(x: f32, y: f32, z: f32) -> Vec<u8> {
        let xi = x as i32 % 255;
        let yi = y as i32 % 255;
        let zi = z as i32 % 255;
        let xf = x - xi as f32;
        let yf = y - yi as f32;
        let zf = z - zi as f32;
        let mut ans = Vec::new();
        for i in 0..8 {
            let delta = Perlin::const_vec_cubical(i).map(|v| max(v as i32, 0));
            let hash = Perlin::PERM[(Perlin::PERM[Perlin::PERM[(xi + delta.x as i32) as usize]
                as usize
                + (yi + delta.y as i32) as usize] as usize
                + (zi + delta.z as i32) as usize) as usize];
            let vec = Perlin::const_vec_cubical(hash);
            ans.push(vec.dot(&Vec3::new(xf, yf, zf)) as u8);
        }
        ans
    }
}

impl Noise3D for Perlin {
    /// perlin noise
    ///
    /// * `x`: x coord
    /// * `y`: y coord
    /// * `z`: z coord
    fn noise(x: f32, y: f32, z: f32) -> f32 {
        let dot = Perlin::gradient_dot(x, y, z);
        let u = Perlin::fade(x - x.floor());
        let v = Perlin::fade(y - y.floor());
        let w = Perlin::fade(z - z.floor());
        let x11 = lerp(
            lerp(dot[0] as f32, dot[1] as f32, u),
            lerp(dot[3] as f32, dot[2] as f32, u),
            v,
        );
        let x12 = lerp(
            lerp(dot[4] as f32, dot[5] as f32, u),
            lerp(dot[7] as f32, dot[6] as f32, u),
            v,
        );
        let y1 = lerp(x11, x12, w);
        let x21 = lerp(
            lerp(dot[0] as f32, dot[1] as f32, u),
            lerp(dot[3] as f32, dot[2] as f32, u),
            v,
        );
        let x22 = lerp(
            lerp(dot[4] as f32, dot[5] as f32, u),
            lerp(dot[7] as f32, dot[6] as f32, u),
            v,
        );
        let y2 = lerp(x21, x22, w);
        (lerp(y1, y2, w) + 1.0) / 2.0
    }
}
